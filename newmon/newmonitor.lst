
; 64tass Turbo Assembler Macro V1.56.2625 listing file
; 64tass -c -b -o monitor.rom -L newmonitor.lst newmonitor.asm
; Wed Sep 14 15:10:27 2022

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: newmonitor.asm

=$fc					zTemp0 = $FC 								; 2 byte memory units.
=6					ClockMhz = 6 								; clock speed in MHz (affects repeat timing)
=1					KeyboardInvert = 1 							; 0 if keyboard active high, 1 if active low.
=$200					StartWorkSpace = $200
=$203					XPosition = $203 							; X Character position
=$204					YPosition = $204 							; Y Character position
=$205					TextColour = $205 							; Text colour
=$206					CurrentPage = $206 							; current I/O page
=$207					LastPS2Code = $207 							; last PS2 code received
=$208					KeyStatus = $208 							; status bits for keys, 18 x 8 bits = 144 bits.
=$209					LastKey = $209 								; one element keyboard queue :)
=538					EndWorkSpace = $208+18
=80					CWidth = 80 								; display size
=60					CHeight = 60
=1					IOPageRegister = 1 							; select I/O Page

;******  Processing file: vicky.inc

=$d000					MASTER_CTRL_REG_L	    = $D000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$d001					MASTER_CTRL_REG_H	    = $D001
=$d002					VKY_RESERVED_00         = $D002
=$d003					VKY_RESERVED_01         = $D003
=$d004					BORDER_CTRL_REG         = $D004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$01					Border_Ctrl_Enable      = $01
=$d005					BORDER_COLOR_B          = $D005
=$d006					BORDER_COLOR_G          = $D006
=$d007					BORDER_COLOR_R          = $D007
=$d008					BORDER_X_SIZE           = $D008; X-  Values: 0 - 32 (Default: 32)
=$d009					BORDER_Y_SIZE           = $D009; Y- Values 0 -32 (Default: 32)
=$d00a					VKY_RESERVED_02         = $D00A
=$d00b					VKY_RESERVED_03         = $D00B
=$d00c					VKY_RESERVED_04         = $D00C
=$d00d					BACKGROUND_COLOR_B      = $D00D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$d00e					BACKGROUND_COLOR_G      = $D00E
=$d00f					BACKGROUND_COLOR_R      = $D00F ;
=$d010					VKY_TXT_CURSOR_CTRL_REG = $D010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$d011					VKY_TXT_START_ADD_PTR   = $D011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$d012					VKY_TXT_CURSOR_CHAR_REG = $D012
=$d013					VKY_TXT_CURSOR_COLR_REG = $D013
=$d014					VKY_TXT_CURSOR_X_REG_L  = $D014
=$d015					VKY_TXT_CURSOR_X_REG_H  = $D015
=$d016					VKY_TXT_CURSOR_Y_REG_L  = $D016
=$d017					VKY_TXT_CURSOR_Y_REG_H  = $D017
=$d018					VKY_LINE_IRQ_CTRL_REG   = $D018 ;[0] - Enable Line 0 - WRITE ONLY
=$d019					VKY_LINE_CMP_VALUE_LO  = $D019 ;Write Only [7:0]
=$d01a					VKY_LINE_CMP_VALUE_HI  = $D01A ;Write Only [3:0]
=$d018					VKY_PIXEL_X_POS_LO     = $D018 ; This is Where on the video line is the Pixel
=$d019					VKY_PIXEL_X_POS_HI     = $D019 ; Or what pixel is being displayed when the register is read
=$d01a					VKY_LINE_Y_POS_LO      = $D01A ; This is the Line Value of the Raster
=$d01b					VKY_LINE_Y_POS_HI      = $D01B ;
=$d100					TyVKY_BM0_CTRL_REG       = $D100
=$01					BM0_Ctrl                = $01       ; Enable the BM0
=$02					BM0_LUT0                = $02       ; LUT0
=$04					BM0_LUT1                = $04       ; LUT1
=$08					BM0_LUT2                = $08       ; LUT2
=$d101					TyVKY_BM0_START_ADDY_L   = $D101
=$d102					TyVKY_BM0_START_ADDY_M   = $D102
=$d103					TyVKY_BM0_START_ADDY_H   = $D103
=$d108					TyVKY_BM1_CTRL_REG       = $D108
=$01					BM1_Ctrl                = $01       ; Enable the BM0
=$02					BM1_LUT0                = $02       ; LUT0
=$04					BM1_LUT1                = $04       ; LUT1
=$08					BM1_LUT2                = $08       ; LUT2
=$d109					TyVKY_BM1_START_ADDY_L   = $D109
=$d10a					TyVKY_BM1_START_ADDY_M   = $D10A
=$d10b					TyVKY_BM1_START_ADDY_H   = $D10B
=$d200					TyVKY_TL_CTRL0          = $D200
=$d300					TyVKY_TL_MISC           = $D300
=$d800					TEXT_LUT_FG      = $D800
=$d840					TEXT_LUT_BG		 = $D840
=$d000					TyVKY_LUT0              = $D000 ; -$D000 - $D3FF
=$d400					TyVKY_LUT1              = $D400 ; -$D400 - $D7FF
=$d800					TyVKY_LUT2              = $D800 ; -$D800 - $DBFF
=$dc00					TyVKY_LUT3              = $DC00 ; -$DC00 - $DFFF

;******  Return to file: newmonitor.asm


;******  Processing file: interrupt.inc

=$d660					INT_PENDING_REG0 = $D660 ;
=$d661					INT_PENDING_REG1 = $D661 ;
=$d662					INT_PENDING_REG2 = $D662 ; NOT USED
=$d663					INT_PENDING_REG3 = $D663 ; NOT USED
=$d664					INT_POL_REG0     = $D664 ;
=$d665					INT_POL_REG1     = $D665 ;
=$d666					INT_POL_REG2     = $D666 ;  NOT USED
=$d667					INT_POL_REG3     = $D667 ; NOT USED
=$d668					INT_EDGE_REG0    = $D668 ;
=$d669					INT_EDGE_REG1    = $D669 ;
=$d66a					INT_EDGE_REG2    = $D66A ; NOT USED
=$d66b					INT_EDGE_REG3    = $D66B ; NOT USED
=$d66c					INT_MASK_REG0    = $D66C ;
=$d66d					INT_MASK_REG1    = $D66D ;
=$d66e					INT_MASK_REG2    = $D66E ; NOT USED
=$d66f					INT_MASK_REG3    = $D66F ; NOT USED
=$01					JR0_INT00_SOF        = $01  ;Start of Frame @ 60FPS
=$02					JR0_INT01_SOL        = $02  ;Start of Line (Programmable)
=$04					JR0_INT02_KBD        = $04  ;
=$08					JR0_INT03_MOUSE      = $08  ;
=$10					JR0_INT04_TMR0       = $10  ;
=$20					JR0_INT05_TMR1       = $20  ;Real-Time Clock Interrupt
=$40					JR0_INT06_DMA        = $40  ;Floppy Disk Controller
=$80					JR0_INT07_TBD        = $80  ; Mouse Interrupt (INT12 in SuperIO IOspace)
=$01					JR1_INT00_UART       = $01  ;Keyboard Interrupt
=$02					JR1_INT01_COL0       = $02  ;TYVKY Collision TBD
=$04					JR1_INT02_COL1       = $04  ;TYVKY Collision TBD
=$08					JR1_INT03_COL2       = $08  ;TYVKY Collision TBD
=$10					JR1_INT04_RTC        = $10  ;Serial Port 1
=$20					JR1_INT05_VIA        = $20  ;Midi Controller Interrupt
=$40					JR1_INT06_IEC        = $40  ;Parallel Port
=$80					JR1_INT07_SDCARD     = $80  ;SDCard Insert

;******  Return to file: newmonitor.asm

.f000					SelectPage0:
.f000	48		pha			pha
.f001	a5 01		lda $01			lda 	IOPageRegister
.f003	29 fc		and #$fc		and 	#$FC
.f005					SelectPageWrite:
.f005	85 01		sta $01			sta 	IOPageRegister
.f007	8d 06 02	sta $0206		sta 	CurrentPage
.f00a	68		pla			pla
.f00b	60		rts			rts
.f00c					SelectPage1:
.f00c	48		pha			pha
.f00d	a5 01		lda $01			lda 	IOPageRegister
.f00f	29 fc		and #$fc		and 	#$FC
.f011	09 01		ora #$01		ora 	#1
.f013	80 f0		bra $f005		bra 	SelectPageWrite
.f015					SelectPage2:
.f015	48		pha			pha
.f016	a5 01		lda $01			lda 	IOPageRegister
.f018	29 fc		and #$fc		and 	#$FC
.f01a	09 02		ora #$02		ora 	#2
.f01c	80 e7		bra $f005		bra 	SelectPageWrite
.f01e					SelectPage3:
.f01e	48		pha			pha
.f01f	a5 01		lda $01			lda 	IOPageRegister
.f021	09 03		ora #$03		ora 	#3
.f023	80 e0		bra $f005		bra 	SelectPageWrite
.f025					ClearScreen:
.f025	da		phx			phx
.f026	20 1e f0	jsr $f01e		jsr 	SelectPage3
.f029	ad 05 02	lda $0205		lda 	TextColour
.f02c	20 39 f0	jsr $f039		jsr 	_ScreenFill
.f02f	20 15 f0	jsr $f015		jsr 	SelectPage2
.f032	a9 20		lda #$20		lda 	#$20
.f034	20 39 f0	jsr $f039		jsr 	_ScreenFill
.f037	fa		plx			plx
.f038	60		rts			rts
.f039					_ScreenFill:
.f039	48		pha			pha
.f03a	a9 c0		lda #$c0		lda 	#$C0 								; fill D000-D7FF with $60
.f03c	85 fd		sta $fd			sta 	zTemp0+1
.f03e	a9 00		lda #$00		lda 	#$00
.f040	85 fc		sta $fc			sta 	zTemp0
.f042	a0 00		ldy #$00		ldy 	#0
.f044	68		pla			pla
.f045					_CLSLoop:
.f045	91 fc		sta ($fc),y		sta 	(zTemp0),y
.f047	c8		iny			iny
.f048	d0 fb		bne $f045		bne 	_CLSLoop
.f04a	e6 fd		inc $fd			inc 	zTemp0+1
.f04c	a6 fd		ldx $fd			ldx 	zTemp0+1
.f04e	e0 d3		cpx #$d3		cpx 	#$D3
.f050	d0 f3		bne $f045		bne 	_CLSLoop
.f052	20 00 f0	jsr $f000		jsr 	SelectPage0
.f055					HomeCursor:
.f055	a9 00		lda #$00		lda 	#0
.f057	8d 03 02	sta $0203		sta 	xPosition
.f05a	8d 04 02	sta $0204		sta 	yPosition
.f05d	20 61 f0	jsr $f061		jsr 	UpdateCursor
.f060	60		rts			rts
.f061					UpdateCursor:
.f061	48		pha			pha
.f062	ad 03 02	lda $0203		lda 	xPosition
.f065	8d 14 d0	sta $d014		sta 	$D014
.f068	ad 04 02	lda $0204		lda 	yPosition
.f06b	8d 16 d0	sta $d016		sta 	$D016
.f06e	68		pla			pla
.f06f	60		rts			rts
.f070					SetZTemp0CharPos:
.f070	48		pha			pha
.f071	8a		txa			txa
.f072	48		pha			pha
.f073	ad 04 02	lda $0204		lda 	yPosition 						; zTemp0 = yPos
.f076	85 fc		sta $fc			sta 	zTemp0
.f078	a9 00		lda #$00		lda 	#0
.f07a	85 fd		sta $fd			sta 	zTemp0+1
.f07c	a2 06		ldx #$06		ldx 	#6 								; x 80
.f07e					_SZ0Shift:
.f07e	06 fc		asl $fc			asl 	zTemp0
.f080	26 fd		rol $fd			rol 	zTemp0+1
.f082	e0 05		cpx #$05		cpx 	#5
.f084	d0 0c		bne $f092		bne 	_SZ0NoAdd
.f086	18		clc			clc
.f087	a5 fc		lda $fc			lda 	zTemp0
.f089	6d 04 02	adc $0204		adc 	yPosition
.f08c	85 fc		sta $fc			sta 	zTemp0
.f08e	90 02		bcc $f092		bcc 	_SZ0NoAdd
.f090	e6 fd		inc $fd			inc 	zTemp0+1
.f092					_SZ0NoAdd:
.f092	ca		dex			dex
.f093	d0 e9		bne $f07e		bne 	_SZ0Shift
.f095	18		clc			clc
.f096	a5 fc		lda $fc			lda 	zTemp0 							; add in xPos
.f098	6d 03 02	adc $0203		adc 	xPosition
.f09b	85 fc		sta $fc			sta 	zTemp0
.f09d	a5 fd		lda $fd			lda 	zTemp0+1 						; point to page D
.f09f	69 c0		adc #$c0		adc 	#$C0
.f0a1	85 fd		sta $fd			sta 	zTemp0+1
.f0a3	68		pla			pla
.f0a4	aa		tax			tax
.f0a5	68		pla			pla
.f0a6	60		rts			rts
.f0a7					PrintCharacter:
.f0a7	20 15 f0	jsr $f015		jsr 	SelectPage2
.f0aa	48		pha			pha
.f0ab	c9 08		cmp #$08		cmp 	#8
.f0ad	f0 4b		beq $f0fa		beq 	_PCBackspace
.f0af	c9 09		cmp #$09		cmp 	#9
.f0b1	f0 39		beq $f0ec		beq 	_PCTab
.f0b3	c9 0d		cmp #$0d		cmp 	#13
.f0b5	f0 54		beq $f10b		beq 	_PCCRLF
.f0b7	20 70 f0	jsr $f070		jsr 	SetZTemp0CharPos 				; all other characters
.f0ba	92 fc		sta ($fc)		sta 	(zTemp0)
.f0bc	20 1e f0	jsr $f01e		jsr 	SelectPage3
.f0bf	ad 05 02	lda $0205		lda 	TextColour
.f0c2	92 fc		sta ($fc)		sta 	(zTemp0)
.f0c4	20 15 f0	jsr $f015		jsr 	SelectPage2
.f0c7	ee 03 02	inc $0203		inc 	xPosition
.f0ca	ad 03 02	lda $0203		lda 	xPosition
.f0cd	c9 50		cmp #$50		cmp  	#CWidth
.f0cf	d0 13		bne $f0e4		bne 	_PCNotRight
.f0d1	9c 03 02	stz $0203		stz 	xPosition
.f0d4	ee 04 02	inc $0204		inc 	yPosition
.f0d7	ad 04 02	lda $0204		lda 	yPosition
.f0da	c9 3c		cmp #$3c		cmp 	#CHeight
.f0dc	d0 06		bne $f0e4		bne 	_PCNotRight
.f0de	ce 04 02	dec $0204		dec 	yPosition
.f0e1	20 18 f1	jsr $f118		jsr 	ScrollScreenUp
.f0e4					_PCNotRight:
.f0e4	68		pla			pla
.f0e5	20 00 f0	jsr $f000		jsr 	SelectPage0
.f0e8	20 61 f0	jsr $f061		jsr 	UpdateCursor
.f0eb	60		rts			rts
.f0ec					_PCTab:
.f0ec	a9 20		lda #$20		lda 	#' '
.f0ee	20 a7 f0	jsr $f0a7		jsr 	PrintCharacter
.f0f1	ad 03 02	lda $0203		lda 	xPosition
.f0f4	29 07		and #$07		and 	#7
.f0f6	d0 f4		bne $f0ec		bne 	_PCTab
.f0f8	80 ea		bra $f0e4		bra 	_PCNotRight
.f0fa					_PCBackspace:
.f0fa	ad 03 02	lda $0203		lda 	xPosition
.f0fd	f0 e5		beq $f0e4		beq 	_PCNotRight
.f0ff	ce 03 02	dec $0203		dec 	xPosition
.f102	20 70 f0	jsr $f070		jsr 	SetZTemp0CharPos
.f105	a9 20		lda #$20		lda 	#' '
.f107	92 fc		sta ($fc)		sta 	(zTemp0)
.f109	80 d9		bra $f0e4		bra 	_PCNotRight
.f10b					_PCCRLF:
.f10b	a9 20		lda #$20		lda 	#$20 							; fill with EOL $20
.f10d	20 a7 f0	jsr $f0a7		jsr 	PrintCharacter
.f110	ad 03 02	lda $0203		lda 	xPosition 						; until back at left
.f113	d0 f6		bne $f10b		bne 	_PCCRLF
.f115	80 cd		bra $f0e4		bra 	_PCNotRight
.f117					NMIHandler:
.f117	40		rti				rti
.f118					ScrollScreenUp:
.f118	98		tya			tya
.f119	48		pha			pha
.f11a	20 1e f0	jsr $f01e		jsr 	SelectPage3
.f11d	20 46 f1	jsr $f146		jsr 	_ScrollBank
.f120	ad 05 02	lda $0205		lda 	TextColour
.f123	20 34 f1	jsr $f134		jsr 	_WriteBottomLine
.f126	20 15 f0	jsr $f015		jsr 	SelectPage2
.f129	20 46 f1	jsr $f146		jsr 	_ScrollBank
.f12c	a9 20		lda #$20		lda 	#32
.f12e	20 34 f1	jsr $f134		jsr 	_WriteBottomLine
.f131	68		pla			pla
.f132	a8		tay			tay
.f133	60		rts			rts
.f134					_WriteBottomLine
.f134	48		pha			pha
.f135	a9 70		lda #$70		lda 	#$70
.f137	85 fc		sta $fc			sta 	zTemp0
.f139	a9 d2		lda #$d2		lda 	#$D2
.f13b	85 fd		sta $fd			sta 	zTemp0+1
.f13d	a0 4f		ldy #$4f		ldy 	#CWidth-1
.f13f	68		pla			pla
.f140					_ScrollBottomLine:
.f140	91 fc		sta ($fc),y		sta 	(zTemp0),y
.f142	88		dey			dey
.f143	10 fb		bpl $f140		bpl 	_ScrollBottomLine
.f145	60		rts			rts
.f146					_ScrollBank
.f146	a9 c0		lda #$c0		lda 	#$C0
.f148	85 fd		sta $fd			sta 	zTemp0+1
.f14a	a9 00		lda #$00		lda 	#$00
.f14c	85 fc		sta $fc			sta 	zTemp0
.f14e	a0 50		ldy #$50		ldy 	#CWidth
.f150					_ScrollLoop:
.f150	b1 fc		lda ($fc),y		lda 	(zTemp0),y
.f152	92 fc		sta ($fc)		sta 	(zTemp0)
.f154	e6 fc		inc $fc			inc 	zTemp0
.f156	d0 f8		bne $f150		bne 	_ScrollLoop
.f158	e6 fd		inc $fd			inc 	zTemp0+1
.f15a	a5 fd		lda $fd			lda 	zTemp0+1
.f15c	c9 d3		cmp #$d3		cmp 	#$D3
.f15e	d0 f0		bne $f150		bne 	_ScrollLoop
.f160	60		rts			rts
.f161					ControlCCheck:
.f161	ad 0a 02	lda $020a		lda 	KeyStatus+2 				; check LCtrl pressed
.f164	29 10		and #$10		and 	#$10
.f166	f0 08		beq $f170		beq 	Exit2
.f168	ad 0c 02	lda $020c		lda 	KeyStatus+4 				; check C pressed
.f16b	29 02		and #$02		and 	#$02 						; non-zero if so
.f16d	49 02		eor #$02		eor 	#$02 				 		; Z set if so.
.f16f	60		rts			rts
.f170					Exit2:
.f170	a9 ff		lda #$ff		lda 	#$FF 						; NZ set
.f172	60		rts			rts
.f173					HandleKeyboard:
.f173	48		pha				pha
.f174	da		phx				phx
.f175	5a		phy				phy
.f176	c9 90		cmp #$90			cmp 	#$90 							; non key PS/2 code
.f178	b0 2d		bcs $f1a7			bcs 	_HKExit
.f17a	48		pha				pha 									; save new code
.f17b	48		pha				pha
.f17c	4a		lsr a				lsr 	a 								; divide by 8 -> X, offset in table
.f17d	4a		lsr a				lsr 	a
.f17e	4a		lsr a				lsr 	a
.f17f	aa		tax				tax
.f180	68		pla				pla
.f181	29 07		and #$07			and 	#7 								; count in Y
.f183	a8		tay				tay
.f184	a9 00		lda #$00			lda 	#0
.f186	38		sec				sec
.f187					_HKGetBits:
.f187	2a		rol a				rol 	a
.f188	88		dey				dey
.f189	10 fc		bpl $f187			bpl 	_HKGetBits
.f18b	ac 07 02	ldy $0207			ldy 	LastPS2Code 					; was last release ?
.f18e	c0 f0		cpy #$f0			cpy 	#$F0  							; could EOR here, may miss PS/2 codes ?
.f190	f0 05		beq $f197			beq 	_HKRelease
.f192	1d 08 02	ora $0208,x			ora 	KeyStatus,x  					; set bit
.f195	80 05		bra $f19c			bra 	_HKWrite
.f197					_HKRelease:
.f197	49 ff		eor #$ff			eor 	#$FF 							; clear bit
.f199	3d 08 02	and $0208,x			and 	KeyStatus,x
.f19c					_HKWrite:
.f19c	9d 08 02	sta $0208,x			sta 	KeyStatus,x
.f19f	68		pla				pla 									; restore new code
.f1a0	c0 f0		cpy #$f0			cpy 	#$F0 							; was it a release
.f1a2	f0 03		beq $f1a7			beq 	_HKExit
.f1a4	20 ae f1	jsr $f1ae			jsr 	ConvertInsertKey
.f1a7					_HKExit:
.f1a7	7a		ply				ply
.f1a8	fa		plx				plx
.f1a9	68		pla				pla
.f1aa	8d 07 02	sta $0207			sta 	LastPS2Code
.f1ad	60		rts				rts
.f1ae					ConvertInsertKey:
.f1ae	aa		tax				tax 								; scan code in X
.f1af	bd 51 f8	lda $f851,x			lda 	ASCIIFromScanCode,x 		; get ASCII unshifted
.f1b2	f0 3a		beq $f1ee			beq 	_CIKExit 					; key not known
.f1b4	a8		tay				tay 								; save in Y
.f1b5	30 26		bmi $f1dd			bmi 	_CIKEndShiftCheck 			; if bit 7 was set shift doesn't affect this.
.f1b7	ad 0a 02	lda $020a			lda 	KeyStatus+2 				; check left shift
.f1ba	29 04		and #$04			and 	#4
.f1bc	d0 07		bne $f1c5			bne 	_CIKShift
.f1be	ad 13 02	lda $0213			lda 	KeyStatus+11 				; check right shift
.f1c1	29 02		and #$02			and 	#2
.f1c3	f0 18		beq $f1dd			beq 	_CIKEndShiftCheck
.f1c5					_CIKShift:
.f1c5	a2 fe		ldx #$fe			ldx 	#254 						; check shift table.
.f1c7					_CIKShiftNext:
.f1c7	e8		inx				inx
.f1c8	e8		inx				inx
.f1c9	3c e2 f8	bit $f8e2,x			bit  	ShiftFixTable,x 			; end of table ?
.f1cc	30 0b		bmi $f1d9			bmi 	_CIDefaultShift
.f1ce	98		tya				tya 								; found a match ?
.f1cf	dd e2 f8	cmp $f8e2,x			cmp 	ShiftFixTable,x
.f1d2	d0 f3		bne $f1c7			bne 	_CIKShiftNext
.f1d4	bc e3 f8	ldy $f8e3,x			ldy 	ShiftFixTable+1,x 			; get replacement
.f1d7	80 04		bra $f1dd			bra 	_CIKEndShiftCheck
.f1d9					_CIDefaultShift:
.f1d9	98		tya				tya 								; default shift.
.f1da	49 20		eor #$20			eor 	#32
.f1dc	a8		tay				tay
.f1dd					_CIKEndShiftCheck:
.f1dd	ad 0a 02	lda $020a			lda 	KeyStatus+2 				; check LCtrl pressed
.f1e0	29 10		and #$10			and 	#$10
.f1e2	f0 04		beq $f1e8			beq 	_CIKNotControl
.f1e4	98		tya				tya 								; lower 5 bits only on control.
.f1e5	29 1f		and #$1f			and 	#31
.f1e7	a8		tay				tay
.f1e8					_CIKNotControl:
.f1e8	98		tya				tya
.f1e9	29 7f		and #$7f			and 	#$7F
.f1eb	8d 09 02	sta $0209			sta 	LastKey 					; save key pressed without bit 7.
.f1ee					_CIKExit:
.f1ee	60		rts				rts
.f1ef					NewReadKeyboard:
.f1ef	ad 09 02	lda $0209			lda 	LastKey 					; wait for key press
.f1f2	f0 fb		beq $f1ef			beq 	NewReadKeyboard
.f1f4	9c 09 02	stz $0209			stz 	LastKey 					; clear queue
.f1f7	60		rts				rts
.f1f8					FakeKeyboardRead:
.f1f8	20 ef f1	jsr $f1ef			jsr 	NewReadKeyboard 			; echo everything except CR, makes
.f1fb	c9 0d		cmp #$0d			cmp 	#13 						; it behave like the C64 with it's
.f1fd	f0 03		beq $f202			beq 	_FKRExit 					; line editing
.f1ff	20 a7 f0	jsr $f0a7			jsr 	PrintCharacter
.f202					_FKRExit:
.f202	60		rts				rts
.f203					GetKeyIfPressed:
.f203	ad 09 02	lda $0209			lda 	LastKey 					; key or zero in A
.f206	9c 09 02	stz $0209			stz 	LastKey 					; consume if pressed, no op if not.
.f209	09 00		ora #$00			ora 	#0 							; set Z and return
.f20b	60		rts				rts
.f20c					SystemReset:
.f20c	a2 ff		ldx #$ff		ldx		#$FF
.f20e	9a		txs			txs
.f20f	a2 1a		ldx #$1a		ldx 	#EndWorkSpace-StartWorkSpace
.f211					_SRClear:
.f211	9e ff 01	stz $01ff,x		stz 	StartWorkSpace-1,x
.f214	ca		dex			dex
.f215	e0 ff		cpx #$ff		cpx 	#$FF
.f217	d0 f8		bne $f211		bne 	_SRClear
.f219	20 00 f0	jsr $f000		jsr 	SelectPage0
.f21c	20 54 f2	jsr $f254		jsr 	TinyVickyInitialise
.f21f	20 9d f2	jsr $f29d		jsr 	Init_Text_LUT
.f222	20 30 f4	jsr $f430		jsr 	LoadGraphicsLUT
.f225	20 25 f0	jsr $f025		jsr 	ClearScreen
.f228	ee 04 02	inc $0204		inc 	yPosition
.f22b	ee 04 02	inc $0204		inc 	yPosition
.f22e	20 00 f0	jsr $f000		jsr 	SelectPage0
.f231	a9 01		lda #$01		lda 	#1
.f233	8d 00 d1	sta $d100		sta 	$D100
.f236	9c 01 d1	stz $d101		stz 	$D101
.f239	9c 02 d1	stz $d102		stz 	$D102
.f23c	9c 03 d1	stz $d103		stz 	$D103
.f23f	a9 4d		lda #$4d		lda 	#"M"
.f241	20 d2 ff	jsr $ffd2		jsr 	$FFD2
.f244	20 4c f3	jsr $f34c		jsr 	INITKEYBOARD
.f247	58		cli			cli
.f248	6c fe 00	jmp ($00fe)		jmp 	($00FE)
.f24b					NextChar:
.f24b	20 ef f1	jsr $f1ef		jsr 	NewReadKeyboard
.f24e	20 a7 f0	jsr $f0a7		jsr 	PrintCharacter
.f251	4c 4b f2	jmp $f24b		jmp 	NextChar

;******  Processing file: hardware.asm

.f254					TinyVickyInitialise:
.f254	a9 01		lda #$01	            lda # Mstr_Ctrl_Text_Mode_En        ; Text on, Overlay,Graphic,Bitmap,Tilemap,Sprite,Gamma,Disable off.
.f256	8d 00 d0	sta $d000	            sta MASTER_CTRL_REG_L               ; Register $D000 in page 0
.f259	ad 00 d0	lda $d000	            lda MASTER_CTRL_REG_L
.f25c	a9 01		lda #$01	            lda #Border_Ctrl_Enable             ; Enable border
.f25e	8d 04 d0	sta $d004	            sta BORDER_CTRL_REG                 ; Register $D004 in page 0
.f261	a9 80		lda #$80	            lda #$80                            ; set border colour to $804000
.f263	8d 05 d0	sta $d005	            sta BORDER_COLOR_B                  ; (registers $D005..$D007)
.f266	a9 00		lda #$00	            lda #$00
.f268	8d 06 d0	sta $d006	            sta BORDER_COLOR_G
.f26b	a9 00		lda #$00	            lda #$00
.f26d	8d 07 d0	sta $d007	            sta BORDER_COLOR_R
.f270	a9 10		lda #$10	            lda #16                             ; border size (offset from top left ?)
.f272	8d 08 d0	sta $d008	            sta BORDER_X_SIZE                   ; (registers $D008 .. $D009)
.f275	8d 09 d0	sta $d009	            sta BORDER_Y_SIZE
.f278	a9 05		lda #$05	            lda #Vky_Cursor_Enable | Vky_Cursor_Flash_Rate1
.f27a	8d 10 d0	sta $d010	            sta VKY_TXT_CURSOR_CTRL_REG         ; turn cursor on ($D010)
.f27d	a9 06		lda #$06	            lda #6
.f27f	8d 12 d0	sta $d012	            sta VKY_TXT_CURSOR_CHAR_REG         ; 160 is 128+32 so inverse space. ($D012)
.f282	a9 1c		lda #$1c	            lda #28
.f284	8d 13 d0	sta $d013	            sta VKY_TXT_CURSOR_COLR_REG         ; colour $2 $8 ($D013)
.f287	a9 00		lda #$00	            lda #0                              ; cursor to (0,5)
.f289	8d 14 d0	sta $d014	            sta VKY_TXT_CURSOR_X_REG_L          ; ($D014 .. $D017)
.f28c	8d 15 d0	sta $d015	            sta VKY_TXT_CURSOR_X_REG_H
.f28f	8d 17 d0	sta $d017	            sta VKY_TXT_CURSOR_Y_REG_H
.f292	a9 05		lda #$05	            lda #5
.f294	8d 16 d0	sta $d016	            sta VKY_TXT_CURSOR_Y_REG_L
.f297	a9 ec		lda #$ec	            lda		#$EC 						; set text colour.
.f299	8d 05 02	sta $0205	            sta 	TextColour
.f29c	60		rts		            rts
.f29d					Init_Text_LUT
.f29d	a2 00		ldx #$00	                LDX #$00
.f29f	bd b8 f2	lda $f2b8,x	lutinitloop0    LDA fg_color_lut,x      ; get Local Data
.f2a2	9d 00 d8	sta $d800,x	                sta TEXT_LUT_FG,x   ; Write in LUT Memory ($D800)
.f2a5	e8		inx		                inx
.f2a6	e0 40		cpx #$40	                cpx #$40
.f2a8	d0 f5		bne $f29f	                bne lutinitloop0
.f2aa	a2 00		ldx #$00	                LDX #$00
.f2ac	bd f8 f2	lda $f2f8,x	lutinitloop1    LDA bg_color_lut,x      ; get Local Data
.f2af	9d 40 d8	sta $d840,x	                STA TEXT_LUT_BG,x   ; Write in LUT Memory ($D840)
.f2b2	e8		inx		                INX
.f2b3	e0 40		cpx #$40	                CPX #$40
.f2b5	d0 f5		bne $f2ac	                bne lutinitloop1
.f2b7	60		rts		                RTS
>f2b8	00 00 00 ff			fg_color_lut    .text $00, $00, $00, $FF
>f2bc	00 00 80 ff			                .text $00, $00, $80, $FF        ; blue
>f2c0	00 80 00 ff			                .text $00, $80, $00, $FF        ; green
>f2c4	80 00 00 ff			                .text $80, $00, $00, $FF        ; red
>f2c8	00 80 80 ff			                .text $00, $80, $80, $FF        ; yellow (etc.)
>f2cc	80 80 00 ff			                .text $80, $80, $00, $FF
>f2d0	80 00 80 ff			                .text $80, $00, $80, $FF
>f2d4	80 80 80 ff			                .text $80, $80, $80, $FF
>f2d8	00 45 ff ff			                .text $00, $45, $FF, $FF
>f2dc	13 45 8b ff			                .text $13, $45, $8B, $FF
>f2e0	00 00 20 ff			                .text $00, $00, $20, $FF
>f2e4	00 20 00 ff			                .text $00, $20, $00, $FF
>f2e8	20 00 00 ff			                .text $20, $00, $00, $FF
>f2ec	20 20 20 ff			                .text $20, $20, $20, $FF
>f2f0	ff 80 00 ff			                .text $FF, $80, $00, $FF
>f2f4	ff ff ff ff			                .text $FF, $FF, $FF, $FF
>f2f8	00 00 00 ff			bg_color_lut    .text $00, $00, $00, $FF  ;BGRA
>f2fc	aa 00 00 ff			                .text $AA, $00, $00, $FF
>f300	00 80 00 ff			                .text $00, $80, $00, $FF
>f304	00 00 80 ff			                .text $00, $00, $80, $FF
>f308	00 20 20 ff			                .text $00, $20, $20, $FF
>f30c	20 20 00 ff			                .text $20, $20, $00, $FF
>f310	20 00 20 ff			                .text $20, $00, $20, $FF
>f314	20 20 20 ff			                .text $20, $20, $20, $FF
>f318	1e 69 d2 ff			                .text $1E, $69, $D2, $FF
>f31c	13 45 8b ff			                .text $13, $45, $8B, $FF
>f320	00 00 20 ff			                .text $00, $00, $20, $FF
>f324	00 20 00 ff			                .text $00, $20, $00, $FF
>f328	40 00 00 ff			                .text $40, $00, $00, $FF
>f32c	10 10 10 ff			                .text $10, $10, $10, $FF
>f330	40 40 40 ff			                .text $40, $40, $40, $FF
>f334	ff ff ff ff			                .text $FF, $FF, $FF, $FF
=$d644					STATUS_PORT     = $D644;
=$d644					KBD_CMD_BUF     = $D644;
=$d640					KBD_OUT_BUF     = $D640;
=$d640					KBD_INPT_BUF    = $D640;
=$d640					KBD_DATA_BUF    = $D640;
=$01					OUT_BUF_FULL    = $01
=$02					INPT_BUF_FULL   = $02
=$04					SYS_FLAG        = $04
=$08					CMD_DATA        = $08
=$10					KEYBD_INH       = $10
=$20					TRANS_TMOUT     = $20
=$40					RCV_TMOUT       = $40
=$80					PARITY_EVEN     = $80
=$10					INH_KEYBOARD    = $10
=$ae					KBD_ENA         = $AE
=$ad					KBD_DIS         = $AD
.f338	ad 44 d6	lda $d644	Poll_Inbuf      lda STATUS_PORT     ; Load Status Byte
.f33b	29 02		and #$02	                and #INPT_BUF_FULL  ; Test bit $02 (if 0, Empty)
.f33d	c9 02		cmp #$02	                cmp #INPT_BUF_FULL
.f33f	f0 f7		beq $f338	                beq Poll_Inbuf
.f341	60		rts		                rts
.f342	ad 44 d6	lda $d644	Poll_Outbuf     lda STATUS_PORT
.f345	29 01		and #$01	                and #OUT_BUF_FULL ; Test bit $01 (if 1, Full)
.f347	c9 01		cmp #$01	                cmp #OUT_BUF_FULL
.f349	d0 f7		bne $f342	                bne Poll_Outbuf
.f34b	60		rts		                rts
.f34c	18		clc		INITKEYBOARD    clc
.f34d	a9 aa		lda #$aa	                lda #$AA                    ; Send self test command
.f34f	8d 44 d6	sta $d644	                sta KBD_CMD_BUF
.f352	20 42 f3	jsr $f342	                jsr Poll_Outbuf             ; Sent Self-Test Code and Waiting for Return value, it ought to be 0x55.
.f355	ad 40 d6	lda $d640	                lda KBD_OUT_BUF             ; Check self test result
.f358	c9 55		cmp #$55	                cmp #$55
.f35a	f0 03		beq $f35f	                beq passAAtest
.f35c	4c ea f3	jmp $f3ea	                jmp initkb_loop_out
.f35f	20 15 f0	jsr $f015	passAAtest      jsr SelectPage2              ; put chr$(31) "1" on top left of screen
.f362	a9 31		lda #$31	                lda #$31
.f364	8d 00 c0	sta $c000	                sta $C000
.f367	20 00 f0	jsr $f000	                jsr SelectPage0
.f36a	20 38 f3	jsr $f338	                jsr Poll_Inbuf
.f36d	a9 ab		lda #$ab	                lda #$AB                     ;Send test Interface command
.f36f	8d 44 d6	sta $d644	                sta KBD_CMD_BUF
.f372	20 42 f3	jsr $f342	                jsr Poll_Outbuf ;
.f375					TryAgainAB:
.f375	ad 40 d6	lda $d640	                lda KBD_OUT_BUF               ;Display Interface test results
.f378	c9 00		cmp #$00	                cmp #$00                      ;Should be 00
.f37a	f0 10		beq $f38c	                beq passABtest
.f37c	d0 f7		bne $f375	                bne TryAgainAB
.f37e	20 15 f0	jsr $f015	                jsr SelectPage2                 ; not reachable
.f381	a9 23		lda #$23	                lda #$23
.f383	8d 05 c0	sta $c005	                sta $C005
.f386	20 00 f0	jsr $f000	                jsr SelectPage0
.f389	4c ea f3	jmp $f3ea	                jmp initkb_loop_out
.f38c	20 15 f0	jsr $f015	passABtest      jsr SelectPage2                  ; put "2" on top left, 2nd character
.f38f	a9 32		lda #$32	                lda #$32
.f391	8d 01 c0	sta $c001	                sta $C001
.f394	20 00 f0	jsr $f000	                jsr SelectPage0
.f397	a9 60		lda #$60	                lda #$60                        ; Send Command 0x60 so to Enable Interrupt
.f399	8d 44 d6	sta $d644	                sta KBD_CMD_BUF
.f39c	20 38 f3	jsr $f338	                jsr Poll_Inbuf
.f39f	a9 41		lda #$41	                lda #%01000001                  ; Enable Interrupt (keyboard) and parallel port (?)
.f3a1	8d 40 d6	sta $d640	                sta KBD_DATA_BUF
.f3a4	20 15 f0	jsr $f015	                jsr SelectPage2                  ; put "3" on 3rd character
.f3a7	a9 33		lda #$33	                lda #$33
.f3a9	8d 02 c0	sta $c002	                sta $C002
.f3ac	20 00 f0	jsr $f000	                jsr SelectPage0
.f3af	20 38 f3	jsr $f338	                jsr Poll_Inbuf;
.f3b2	a9 ff		lda #$ff	                lda #$FF      ; Send Keyboard Reset command
.f3b4	8d 40 d6	sta $d640	                sta KBD_DATA_BUF
.f3b7	a0 ff		ldy #$ff	                 ldy #$FF
.f3b9	a2 ff		ldx #$ff	DLY_LOOP2       ldx #$FF
.f3bb	ca		dex		DLY_LOOP1       dex
.f3bc	ea		nop		                nop
.f3bd	ea		nop		                nop
.f3be	ea		nop		                nop
.f3bf	ea		nop		                nop
.f3c0	e0 00		cpx #$00	                cpx #$00
.f3c2	d0 f7		bne $f3bb	                bne DLY_LOOP1
.f3c4	88		dey		                dey
.f3c5	c0 00		cpy #$00	                cpy #$00
.f3c7	d0 f0		bne $f3b9	                bne DLY_LOOP2
.f3c9	ea		nop		                nop
.f3ca	20 42 f3	jsr $f342	                jsr Poll_Outbuf ;
.f3cd	ad 40 d6	lda $d640	                lda KBD_OUT_BUF                 ; Read Output Buffer
.f3d0	20 15 f0	jsr $f015	                jsr SelectPage2                     ;
.f3d3	a9 34		lda #$34	                lda #$34                        ; put "4" in fourth slot.
.f3d5	8d 03 c0	sta $c003	                sta $C003
.f3d8	20 00 f0	jsr $f000	                jsr SelectPage0
.f3db					DO_CMD_F4_AGAIN
.f3db	20 38 f3	jsr $f338	                jsr Poll_Inbuf ;
.f3de	a9 f4		lda #$f4	                lda #$F4                        ; Enable the Keyboard
.f3e0	8d 40 d6	sta $d640	                sta KBD_DATA_BUF
.f3e3	20 42 f3	jsr $f342	                jsr Poll_Outbuf ;
.f3e6	ad 40 d6	lda $d640	                lda KBD_OUT_BUF                  ; Clear the Output buffer
.f3e9	60		rts		                rts
.f3ea					initkb_loop_out
.f3ea	60		rts		                rts
.f3eb					IRQHandler
.f3eb	48		pha		                pha
.f3ec	ad 06 02	lda $0206	                lda     CurrentPage                 ; switch to page 0
.f3ef	29 fc		and #$fc	                and     #$FC
.f3f1	85 01		sta $01		                sta     IOPageRegister
.f3f3	ad 60 d6	lda $d660	                LDA INT_PENDING_REG0                ; received reg0 SOL interrupt
.f3f6	c9 00		cmp #$00	                CMP #$00
.f3f8	f0 28		beq $f422	                BEQ CHECK_PENDING_REG1
.f3fa	ad 60 d6	lda $d660	                LDA INT_PENDING_REG0                ; was it SOL interrupt
.f3fd	29 02		and #$02	                AND #JR0_INT01_SOL
.f3ff	c9 02		cmp #$02	                CMP #JR0_INT01_SOL
.f401	d0 0b		bne $f40e	                BNE CHECK_KEYBOARD                  ; bug, was pending S1
.f403	8d 60 d6	sta $d660	                STA INT_PENDING_REG0
.f406	ad 07 d0	lda $d007	                lda BORDER_COLOR_R                  ; change the background colour.
.f409	69 01		adc #$01	                adc #$01
.f40b	8d 07 d0	sta $d007	                sta BORDER_COLOR_R
.f40e					CHECK_KEYBOARD
.f40e	ad 60 d6	lda $d660	                LDA INT_PENDING_REG0                ; received Keyboard interrupt ?
.f411	29 04		and #$04	                AND #JR0_INT02_KBD
.f413	c9 04		cmp #$04	                CMP #JR0_INT02_KBD
.f415	d0 0b		bne $f422	                BNE CHECK_PENDING_REG1
.f417	8d 60 d6	sta $d660	                STA INT_PENDING_REG0
.f41a	ad 40 d6	lda $d640	                LDA KBD_INPT_BUF                    ; Get Scan Code from KeyBoard
.f41d	20 73 f1	jsr $f173	                jsr     HandleKeyboard
.f420	80 00		bra $f422	                bra CHECK_PENDING_REG1
.f422					CHECK_PENDING_REG1
.f422	ad 61 d6	lda $d661	                LDA INT_PENDING_REG1
.f425	c9 00		cmp #$00	                CMP #$00
.f427	f0 00		beq $f429	                BEQ EXIT_IRQ_HANDLE
.f429					EXIT_IRQ_HANDLE
.f429	ad 06 02	lda $0206	                lda     CurrentPage                 ; restore current I/O Page
.f42c	85 01		sta $01		                sta     IOPageRegister
.f42e	68		pla		                pla
.f42f	40		rti		                RTI
.f430					LoadGraphicsLUT:
.f430	20 0c f0	jsr $f00c	            jsr     SelectPage1
.f433	a2 00		ldx #$00	            ldx     #0
.f435	bd 51 f4	lda $f451,x	_LGLLoop:   lda     _GraphicsLUT,x
.f438	9d 00 d0	sta $d000,x	            sta     TyVKY_LUT0,x
.f43b	bd 51 f5	lda $f551,x	            lda     _GraphicsLUT+256,x
.f43e	9d 00 d1	sta $d100,x	            sta     TyVKY_LUT0+256,x
.f441	bd 51 f6	lda $f651,x	            lda     _GraphicsLUT+512,x
.f444	9d 00 d2	sta $d200,x	            sta     TyVKY_LUT0+512,x
.f447	bd 51 f7	lda $f751,x	            lda     _GraphicsLUT+768,x
.f44a	9d 00 d3	sta $d300,x	            sta     TyVKY_LUT0+768,x
.f44d	ca		dex		            dex
.f44e	d0 e5		bne $f435	            bne     _LGLLoop
.f450	60		rts		            rts
.f451					_GraphicsLUT:
>f451	00 00 00 00 aa 00 00 00		            .binary    "gfxlut.palette"
>f459	00 aa 00 00 aa aa 00 00 00 00 aa 00 aa 00 aa 00
>f469	00 55 aa 00 aa aa aa 00 55 55 55 00 ff 55 55 00
>f479	55 ff 55 00 ff ff 55 00 55 55 ff 00 ff 55 ff 00
>f489	55 ff ff 00 ff ff ff 00 00 00 00 00 10 10 10 00
>f499	20 20 20 00 35 35 35 00 45 45 45 00 55 55 55 00
>f4a9	65 65 65 00 75 75 75 00 8a 8a 8a 00 9a 9a 9a 00
>f4b9	aa aa aa 00 ba ba ba 00 ca ca ca 00 df df df 00
>f4c9	ef ef ef 00 ff ff ff 00 ff 00 00 00 ff 00 41 00
>f4d9	ff 00 82 00 ff 00 be 00 ff 00 ff 00 be 00 ff 00
>f4e9	82 00 ff 00 41 00 ff 00 00 00 ff 00 00 41 ff 00
>f4f9	00 82 ff 00 00 be ff 00 00 ff ff 00 00 ff be 00
>f509	00 ff 82 00 00 ff 41 00 00 ff 00 00 41 ff 00 00
>f519	82 ff 00 00 be ff 00 00 ff ff 00 00 ff be 00 00
>f529	ff 82 00 00 ff 41 00 00 ff 82 82 00 ff 82 9e 00
>f539	ff 82 be 00 ff 82 df 00 ff 82 ff 00 df 82 ff 00
>f549	be 82 ff 00 9e 82 ff 00 82 82 ff 00 82 9e ff 00
>f559	82 be ff 00 82 df ff 00 82 ff ff 00 82 ff df 00
>f569	82 ff be 00 82 ff 9e 00 82 ff 82 00 9e ff 82 00
>f579	be ff 82 00 df ff 82 00 ff ff 82 00 ff df 82 00
>f589	ff be 82 00 ff 9e 82 00 ff ba ba 00 ff ba ca 00
>f599	ff ba df 00 ff ba ef 00 ff ba ff 00 ef ba ff 00
>f5a9	df ba ff 00 ca ba ff 00 ba ba ff 00 ba ca ff 00
>f5b9	ba df ff 00 ba ef ff 00 ba ff ff 00 ba ff ef 00
>f5c9	ba ff df 00 ba ff ca 00 ba ff ba 00 ca ff ba 00
>f5d9	df ff ba 00 ef ff ba 00 ff ff ba 00 ff ef ba 00
>f5e9	ff df ba 00 ff ca ba 00 71 00 00 00 71 00 1c 00
>f5f9	71 00 39 00 71 00 55 00 71 00 71 00 55 00 71 00
>f609	39 00 71 00 1c 00 71 00 00 00 71 00 00 1c 71 00
>f619	00 39 71 00 00 55 71 00 00 71 71 00 00 71 55 00
>f629	00 71 39 00 00 71 1c 00 00 71 00 00 1c 71 00 00
>f639	39 71 00 00 55 71 00 00 71 71 00 00 71 55 00 00
>f649	71 39 00 00 71 1c 00 00 71 39 39 00 71 39 45 00
>f659	71 39 55 00 71 39 61 00 71 39 71 00 61 39 71 00
>f669	55 39 71 00 45 39 71 00 39 39 71 00 39 45 71 00
>f679	39 55 71 00 39 61 71 00 39 71 71 00 39 71 61 00
>f689	39 71 55 00 39 71 45 00 39 71 39 00 45 71 39 00
>f699	55 71 39 00 61 71 39 00 71 71 39 00 71 61 39 00
>f6a9	71 55 39 00 71 45 39 00 71 51 51 00 71 51 59 00
>f6b9	71 51 61 00 71 51 69 00 71 51 71 00 69 51 71 00
>f6c9	61 51 71 00 59 51 71 00 51 51 71 00 51 59 71 00
>f6d9	51 61 71 00 51 69 71 00 51 71 71 00 51 71 69 00
>f6e9	51 71 61 00 51 71 59 00 51 71 51 00 59 71 51 00
>f6f9	61 71 51 00 69 71 51 00 71 71 51 00 71 69 51 00
>f709	71 61 51 00 71 59 51 00 41 00 00 00 41 00 10 00
>f719	41 00 20 00 41 00 31 00 41 00 41 00 31 00 41 00
>f729	20 00 41 00 10 00 41 00 00 00 41 00 00 10 41 00
>f739	00 20 41 00 00 31 41 00 00 41 41 00 00 41 31 00
>f749	00 41 20 00 00 41 10 00 00 41 00 00 10 41 00 00
>f759	20 41 00 00 31 41 00 00 41 41 00 00 41 31 00 00
>f769	41 20 00 00 41 10 00 00 41 20 20 00 41 20 28 00
>f779	41 20 31 00 41 20 39 00 41 20 41 00 39 20 41 00
>f789	31 20 41 00 28 20 41 00 20 20 41 00 20 28 41 00
>f799	20 31 41 00 20 39 41 00 20 41 41 00 20 41 39 00
>f7a9	20 41 31 00 20 41 28 00 20 41 20 00 28 41 20 00
>f7b9	31 41 20 00 39 41 20 00 41 41 20 00 41 39 20 00
>f7c9	41 31 20 00 41 28 20 00 41 2d 2d 00 41 2d 31 00
>f7d9	41 2d 35 00 41 2d 3d 00 41 2d 41 00 3d 2d 41 00
>f7e9	35 2d 41 00 31 2d 41 00 2d 2d 41 00 2d 31 41 00
>f7f9	2d 35 41 00 2d 3d 41 00 2d 41 41 00 2d 41 3d 00
>f809	2d 41 35 00 2d 41 31 00 2d 41 2d 00 31 41 2d 00
>f819	35 41 2d 00 3d 41 2d 00 41 41 2d 00 41 3d 2d 00
>f829	41 35 2d 00 41 31 2d 00 00 00 00 00 00 00 00 00
>f839	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>f849	00 00 00 00 00 00 00 00

;******  Return to file: newmonitor.asm


;******  Processing file: ps2convert.inc

.f851					ASCIIFromScanCode:
>f851	00					.byte	$00 ; 0
>f852	00					.byte	$00 ; 1
>f853	00					.byte	$00 ; 2
>f854	00					.byte	$00 ; 3
>f855	00					.byte	$00 ; 4
>f856	00					.byte	$00 ; 5
>f857	00					.byte	$00 ; 6
>f858	00					.byte	$00 ; 7
>f859	00					.byte	$00 ; 8
>f85a	00					.byte	$00 ; 9
>f85b	00					.byte	$00 ; 10
>f85c	00					.byte	$00 ; 11
>f85d	00					.byte	$00 ; 12
>f85e	89					.byte	$89 ; 13 Tab
>f85f	00					.byte	$00 ; 14
>f860	00					.byte	$00 ; 15
>f861	00					.byte	$00 ; 16
>f862	00					.byte	$00 ; 17 Left Alt
>f863	00					.byte	$00 ; 18 Left Shift
>f864	00					.byte	$00 ; 19
>f865	00					.byte	$00 ; 20 Left Ctrl
>f866	71					.byte	$71 ; 21 q
>f867	31					.byte	$31 ; 22 1
>f868	00					.byte	$00 ; 23
>f869	00					.byte	$00 ; 24
>f86a	00					.byte	$00 ; 25
>f86b	7a					.byte	$7a ; 26 z
>f86c	73					.byte	$73 ; 27 s
>f86d	61					.byte	$61 ; 28 a
>f86e	77					.byte	$77 ; 29 w
>f86f	32					.byte	$32 ; 30 2
>f870	00					.byte	$00 ; 31
>f871	00					.byte	$00 ; 32
>f872	63					.byte	$63 ; 33 c
>f873	78					.byte	$78 ; 34 x
>f874	64					.byte	$64 ; 35 d
>f875	65					.byte	$65 ; 36 e
>f876	34					.byte	$34 ; 37 4
>f877	33					.byte	$33 ; 38 3
>f878	00					.byte	$00 ; 39
>f879	00					.byte	$00 ; 40
>f87a	a0					.byte	$a0 ; 41 Space
>f87b	76					.byte	$76 ; 42 v
>f87c	66					.byte	$66 ; 43 f
>f87d	74					.byte	$74 ; 44 t
>f87e	72					.byte	$72 ; 45 r
>f87f	35					.byte	$35 ; 46 5
>f880	00					.byte	$00 ; 47
>f881	00					.byte	$00 ; 48
>f882	6e					.byte	$6e ; 49 n
>f883	62					.byte	$62 ; 50 b
>f884	68					.byte	$68 ; 51 h
>f885	67					.byte	$67 ; 52 g
>f886	79					.byte	$79 ; 53 y
>f887	36					.byte	$36 ; 54 6
>f888	00					.byte	$00 ; 55
>f889	00					.byte	$00 ; 56
>f88a	00					.byte	$00 ; 57
>f88b	6d					.byte	$6d ; 58 m
>f88c	6a					.byte	$6a ; 59 j
>f88d	75					.byte	$75 ; 60 u
>f88e	37					.byte	$37 ; 61 7
>f88f	38					.byte	$38 ; 62 8
>f890	00					.byte	$00 ; 63
>f891	00					.byte	$00 ; 64
>f892	2c					.byte	$2c ; 65 ,
>f893	6b					.byte	$6b ; 66 k
>f894	69					.byte	$69 ; 67 i
>f895	6f					.byte	$6f ; 68 o
>f896	30					.byte	$30 ; 69 0
>f897	39					.byte	$39 ; 70 9
>f898	00					.byte	$00 ; 71
>f899	00					.byte	$00 ; 72
>f89a	2e					.byte	$2e ; 73 .
>f89b	2f					.byte	$2f ; 74 /
>f89c	6c					.byte	$6c ; 75 l
>f89d	3b					.byte	$3b ; 76 ;
>f89e	70					.byte	$70 ; 77 p
>f89f	2d					.byte	$2d ; 78 -
>f8a0	00					.byte	$00 ; 79
>f8a1	00					.byte	$00 ; 80
>f8a2	00					.byte	$00 ; 81
>f8a3	27					.byte	$27 ; 82 '
>f8a4	00					.byte	$00 ; 83
>f8a5	5b					.byte	$5b ; 84 [
>f8a6	3d					.byte	$3d ; 85 =
>f8a7	00					.byte	$00 ; 86
>f8a8	00					.byte	$00 ; 87
>f8a9	00					.byte	$00 ; 88
>f8aa	00					.byte	$00 ; 89 Right Shift
>f8ab	8d					.byte	$8d ; 90 Enter
>f8ac	5d					.byte	$5d ; 91 ]
>f8ad	00					.byte	$00 ; 92
>f8ae	dc					.byte	$dc ; 93 \
>f8af	00					.byte	$00 ; 94
>f8b0	00					.byte	$00 ; 95
>f8b1	00					.byte	$00 ; 96
>f8b2	00					.byte	$00 ; 97
>f8b3	00					.byte	$00 ; 98
>f8b4	00					.byte	$00 ; 99
>f8b5	00					.byte	$00 ; 100
>f8b6	00					.byte	$00 ; 101
>f8b7	88					.byte	$88 ; 102 Backspace
>f8b8	00					.byte	$00 ; 103
>f8b9	00					.byte	$00 ; 104
>f8ba	00					.byte	$00 ; 105
>f8bb	00					.byte	$00 ; 106
>f8bc	00					.byte	$00 ; 107
>f8bd	00					.byte	$00 ; 108
>f8be	00					.byte	$00 ; 109
>f8bf	00					.byte	$00 ; 110
>f8c0	00					.byte	$00 ; 111
>f8c1	00					.byte	$00 ; 112
>f8c2	00					.byte	$00 ; 113
>f8c3	00					.byte	$00 ; 114
>f8c4	00					.byte	$00 ; 115
>f8c5	00					.byte	$00 ; 116
>f8c6	00					.byte	$00 ; 117
>f8c7	cc					.byte	$cc ; 118 Esc
>f8c8	00					.byte	$00 ; 119
>f8c9	00					.byte	$00 ; 120
>f8ca	00					.byte	$00 ; 121
>f8cb	00					.byte	$00 ; 122
>f8cc	00					.byte	$00 ; 123
>f8cd	00					.byte	$00 ; 124
>f8ce	00					.byte	$00 ; 125
>f8cf	00					.byte	$00 ; 126
>f8d0	00					.byte	$00 ; 127
>f8d1	00					.byte	$00 ; 128
>f8d2	00					.byte	$00 ; 129
>f8d3	00					.byte	$00 ; 130
>f8d4	00					.byte	$00 ; 131
>f8d5	00					.byte	$00 ; 132
>f8d6	00					.byte	$00 ; 133
>f8d7	00					.byte	$00 ; 134
>f8d8	00					.byte	$00 ; 135
>f8d9	00					.byte	$00 ; 136
>f8da	00					.byte	$00 ; 137
>f8db	00					.byte	$00 ; 138
>f8dc	00					.byte	$00 ; 139
>f8dd	00					.byte	$00 ; 140
>f8de	00					.byte	$00 ; 141
>f8df	00					.byte	$00 ; 142
>f8e0	00					.byte	$00 ; 143
>f8e1	ff					.byte	$FF
.f8e2					ShiftFixTable:
>f8e2	31					.byte	$31 ; "1"
>f8e3	21					.byte	$21 ; "!"
>f8e4	32					.byte	$32 ; "2"
>f8e5	40					.byte	$40 ; "@"
>f8e6	33					.byte	$33 ; "3"
>f8e7	23					.byte	$23 ; "#"
>f8e8	34					.byte	$34 ; "4"
>f8e9	24					.byte	$24 ; "$"
>f8ea	35					.byte	$35 ; "5"
>f8eb	25					.byte	$25 ; "%"
>f8ec	36					.byte	$36 ; "6"
>f8ed	5e					.byte	$5e ; "^"
>f8ee	37					.byte	$37 ; "7"
>f8ef	26					.byte	$26 ; "&"
>f8f0	38					.byte	$38 ; "8"
>f8f1	2a					.byte	$2a ; "*"
>f8f2	39					.byte	$39 ; "9"
>f8f3	28					.byte	$28 ; "("
>f8f4	30					.byte	$30 ; "0"
>f8f5	29					.byte	$29 ; ")"
>f8f6	2d					.byte	$2d ; "-"
>f8f7	5f					.byte	$5f ; "_"
>f8f8	3d					.byte	$3d ; "="
>f8f9	2b					.byte	$2b ; "+"
>f8fa	3b					.byte	$3b ; ";"
>f8fb	3a					.byte	$3a ; ":"
>f8fc	27					.byte	$27 ; "'"
>f8fd	22					.byte	$22 ; """
>f8fe	2c					.byte	$2c ; ","
>f8ff	3c					.byte	$3c ; "<"
>f900	2e					.byte	$2e ; "."
>f901	3e					.byte	$3e ; ">"
>f902	2f					.byte	$2f ; "/"
>f903	3f					.byte	$3f ; "?"
>f904	ff					.byte	$FF

;******  Return to file: newmonitor.asm

.ffcf	4c f8 f1	jmp $f1f8		jmp 	FakeKeyboardRead
.ffd2	4c a7 f0	jmp $f0a7		jmp 	PrintCharacter
.ffe1	4c 61 f1	jmp $f161		jmp 	ControlCCheck
.ffe4	4c 03 f2	jmp $f203		jmp 	GetKeyIfPressed
>fffa	17 f1					.word 	NMIHandler                       	; nmi ($FFFA)
>fffc	0c f2					.word 	SystemReset                         ; reset ($FFFC)
>fffe	eb f3					.word 	IRQHandler                          ; irq ($FFFE)

;******  End of listing
